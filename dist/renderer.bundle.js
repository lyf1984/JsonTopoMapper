/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/renderer/config/networkConfig.js":
/*!*************************************************!*\
  !*** ./src/js/renderer/config/networkConfig.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DIR: () => (/* binding */ DIR),\n/* harmony export */   EDGE_LENGTH_MAIN: () => (/* binding */ EDGE_LENGTH_MAIN),\n/* harmony export */   EDGE_LENGTH_SUB: () => (/* binding */ EDGE_LENGTH_SUB),\n/* harmony export */   getNetworkOptions: () => (/* binding */ getNetworkOptions)\n/* harmony export */ });\nconst DIR = 'assets/refresh-cl/';\nconst EDGE_LENGTH_MAIN = 100;\nconst EDGE_LENGTH_SUB = 50;\nconst getNetworkOptions = () => ({\n  autoResize: true,\n  height: '100%',\n  width: '100%',\n  nodes: {\n    font: {\n      color: \"#595959\",\n      size: 5\n    }\n  },\n  edges: {\n    smooth: false,\n    //是否显示方向箭头\n    color: \"#c8c8c8\" // 线条颜色\n  },\n  layout: {\n    improvedLayout: false\n  },\n  interaction: {\n    navigationButtons: false,\n    // 如果为真，则在网络画布上绘制导航按钮。这些是HTML按钮，可以使用CSS完全自定义。\n    keyboard: {\n      enabled: false\n    } // 启用键盘快捷键\n  },\n  physics: {\n    enabled: true,\n    solver: \"barnesHut\",\n    barnesHut: {\n      gravitationalConstant: -4000,\n      centralGravity: 0.3,\n      springLength: 120,\n      springConstant: 0.04,\n      damping: 0.09,\n      avoidOverlap: 0.2\n    }\n  },\n  interaction: {\n    hover: true\n  }\n});\n\n//# sourceURL=webpack://network-topology/./src/js/renderer/config/networkConfig.js?");

/***/ }),

/***/ "./src/js/renderer/handlers/dataHandlers.js":
/*!**************************************************!*\
  !*** ./src/js/renderer/handlers/dataHandlers.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   addNodeWithChildren: () => (/* binding */ addNodeWithChildren),\n/* harmony export */   calculateVulnerability: () => (/* binding */ calculateVulnerability),\n/* harmony export */   handleEdgeNode: () => (/* binding */ handleEdgeNode)\n/* harmony export */ });\n/* harmony import */ var _utils_state_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/state.js */ \"./src/js/renderer/utils/state.js\");\n/* harmony import */ var _config_networkConfig_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config/networkConfig.js */ \"./src/js/renderer/config/networkConfig.js\");\n/**\n * 网络节点处理模块\n * 功能：实现网络节点的递归创建、子节点处理及边缘节点处理逻辑\n */\n\n// 导入依赖\n\n\n\n/* ======================== 核心节点处理函数 ======================== */\n\n/**\n * 递归创建节点及其子节点结构\n * @param {Object} node - 当前节点数据对象\n * @param {Object} data - 完整数据集（包含所有节点定义）\n * @param {number|null} parentId - 父节点ID（顶层节点为null）\n * @returns {void}\n */\nconst addNodeWithChildren = (node, data, parentId) => {\n  var currentNodeId;\n  //是否已创建\n  if (!_utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.ipToId.has(node.node_id)) {\n    // 生成当前节点唯一ID并维护IP映射关系\n    currentNodeId = _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.incrementId();\n    // 创建当前节点对象\n    _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.nodes.add({\n      id: currentNodeId,\n      label: node.node_id,\n      node_type: node.node_type,\n      state: node.state,\n      fqdn: node.fqdn,\n      reverse_dns: node.reverse_dns,\n      mac_address: node.mac_address,\n      vendor: node.vendor,\n      open_ports: node.open_ports,\n      os: node.os,\n      children: node.children,\n      parent: node.parent,\n      // 可视化样式配置\n      shape: \"circle\",\n      color: node.node_type === \"subnet\" ? {\n        // 子网专用颜色（蓝色系）\n        background: \"#87CEEB\",\n        border: \"#4682B4\",\n        highlight: {\n          background: \"#B0E0E6\",\n          border: \"#5F9EA0\"\n        },\n        hover: {\n          background: \"#B0E0E6\",\n          border: \"#4682B4\"\n        }\n      } : {\n        // 默认颜色（黄色系）\n        background: \"#F0E68C\",\n        border: \"#B8860B\",\n        highlight: {\n          background: \"#FFD700\",\n          border: \"#DAA520\"\n        },\n        hover: {\n          background: \"#FFD700\",\n          border: \"#8B7500\"\n        }\n      },\n      shadow: {\n        enabled: true,\n        color: \"rgba(0, 0, 0, 0.5)\",\n        size: 10,\n        x: 5,\n        y: 5\n      },\n      opacity: 1\n    });\n    _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.ipToId.set(node.node_id, currentNodeId);\n  }\n  currentNodeId = _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.ipToId.get(node.node_id);\n  /* ---------------------- 父子节点连接处理 ---------------------- */\n  if (parentId !== null) {\n    _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.edges.add({\n      from: parentId,\n      to: currentNodeId,\n      length: _config_networkConfig_js__WEBPACK_IMPORTED_MODULE_1__.EDGE_LENGTH_MAIN,\n      // 使用预定义的主干边长度\n      color: '#808080',\n      dashes: true\n    });\n  }\n\n  /* ---------------------- 子节点递归处理 ---------------------- */\n  if (node.node_type === 'subnet' && node.children) {\n    node.children.forEach(childId => {\n      // 在数据集中查找子节点定义\n      const childNode = data.nodes.find(n => n.node_id === childId);\n      if (childNode) {\n        // 递归创建有效子节点\n        addNodeWithChildren(childNode, data, currentNodeId);\n\n        // 获取子节点在 appState.nodes 中的实际 id\n        const childNodeActualId = _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.ipToId.get(childNode.node_id);\n        if (childNodeActualId) {\n          const childNodeObj = _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.nodes.get(childNodeActualId);\n          if (childNodeObj && !childNodeObj.parent) {\n            childNodeObj.parent = currentNodeId;\n            // 更新节点数据\n            _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.nodes.update(childNodeObj);\n          }\n        }\n      } else {\n        // 创建占位节点处理数据缺失情况\n        console.warn(`子节点 ${childId} 未定义，创建占位节点`);\n        addNodeWithChildren({\n          node_id: childId,\n          node_type: 'unknown',\n          state: 'down',\n          parent: currentNodeId\n        }, data, currentNodeId);\n      }\n    });\n  }\n};\n/* ======================== 脆弱性分析算法 ======================== */\n/**\n * 计算网络脆弱性（基于端口数）\n */\nconst calculateVulnerability = () => {\n  const connectionThreshold = 3; // 连接数阈值\n\n  _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.nodes.forEach(node => {\n    const portCount = node.open_ports ? node.open_ports.length : 0;\n    node.vulnerable = portCount > 5;\n    if (node.vulnerable) {\n      // 存储原始颜色\n      const originalColor = {\n        ...node.color\n      };\n      const blinkColor = {\n        background: '#FF6B6B',\n        border: '#CC0000',\n        highlight: {\n          background: '#FF9999',\n          border: '#FF4444'\n        }\n      };\n      let isBlinking = false;\n      // 每 500ms 切换一次颜色\n\n      node.color = isBlinking ? originalColor : blinkColor;\n      _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.nodes.update(node);\n    }\n  });\n};\n\n/* ======================== 边处理函数 ======================== */\nconst addEdge = (edge, data) => {\n  const fromId = handleEdgeNode(edge.from_node, data);\n  const toId = handleEdgeNode(edge.to_node, data);\n\n  // 检查边是否已经存在\n  const existingEdge = _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.edges.get({\n    filter: e => e.from === fromId && e.to === toId\n  });\n  if (existingEdge.length === 0) {\n    // 创建边对象\n    _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.edges.add({\n      from: fromId,\n      to: toId,\n      length: _config_networkConfig_js__WEBPACK_IMPORTED_MODULE_1__.EDGE_LENGTH_MAIN,\n      // 使用预设边长度\n      edge_type: edge.edge_type,\n      // 边类型（物理连接/逻辑连接等）\n      protocol: edge.protocol,\n      // 网络协议\n      layer: edge.layer,\n      // 网络层次（如L2/L3）\n      color: 'black'\n    });\n  }\n};\n\n/* ======================== 节点两端处理函数 ======================== */\n\n/**\n * 处理边缘节点逻辑（动态创建未定义的节点）\n * @param {string} nodeId - 需要处理的节点ID\n * @returns {number} 节点在系统中的实际ID\n */\nconst handleEdgeNode = (nodeId, data) => {\n  // 检查节点是否已存在\n  if (!_utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.ipToId.has(nodeId)) {\n    // 尝试在原始数据中查找节点定义\n    const originalNode = data.nodes.find(n => n.node_id === nodeId);\n    if (originalNode) {\n      // 创建完整定义的节点\n      addNodeWithChildren(originalNode, data, nodeId);\n    } else {\n      // 创建自动生成的临时节点\n      const newId = _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.incrementId();\n      _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.nodes.add({\n        id: newId,\n        label: nodeId,\n        node_type: 'auto',\n        shape: \"circle\",\n        color: {\n          background: \"#E0FFFF\",\n          border: \"#4682B4\",\n          highlight: {\n            background: \"#AFEEEE\",\n            border: \"#5F9EA0\"\n          },\n          hover: {\n            background: \"#AFEEEE\",\n            border: \"#5F9EA0\"\n          }\n        },\n        title: `自动生成节点: ${nodeId}`\n      });\n      _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.ipToId.set(nodeId, newId);\n    }\n  }\n  return _utils_state_js__WEBPACK_IMPORTED_MODULE_0__.appState.ipToId.get(nodeId);\n};\n\n//# sourceURL=webpack://network-topology/./src/js/renderer/handlers/dataHandlers.js?");

/***/ }),

/***/ "./src/js/renderer/handlers/eventHandlers.js":
/*!***************************************************!*\
  !*** ./src/js/renderer/handlers/eventHandlers.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   setupNetworkEvents: () => (/* binding */ setupNetworkEvents)\n/* harmony export */ });\n/* harmony import */ var _config_networkConfig_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/networkConfig.js */ \"./src/js/renderer/config/networkConfig.js\");\n/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils.js */ \"./src/js/renderer/utils/utils.js\");\n/* harmony import */ var _utils_state_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/state.js */ \"./src/js/renderer/utils/state.js\");\n/* harmony import */ var _dataHandlers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dataHandlers.js */ \"./src/js/renderer/handlers/dataHandlers.js\");\n/**\r\n * 网络图事件处理模块\r\n * 功能：处理网络图的交互事件，包括稳定状态处理、右键菜单、节点操作等\r\n */\n\n// 导入依赖模块\n\n\n\n\n\n/**\r\n * 处理网络图稳定状态事件\r\n * @param {number} stabilizedTimer - 稳定状态定时器\r\n * @returns {number} - 更新后的稳定状态定时器\r\n */\nconst handleStabilized = stabilizedTimer => {\n  clearTimeout(stabilizedTimer);\n  stabilizedTimer = setTimeout(() => {\n    const options = (0,_config_networkConfig_js__WEBPACK_IMPORTED_MODULE_0__.getNetworkOptions)();\n    options.physics.enabled = false;\n    _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.setOptions(options);\n  }, 300);\n  return stabilizedTimer;\n};\n\n/**\r\n * 处理网络图右键上下文菜单事件\r\n * @param {Object} params - 事件参数\r\n * @param {string|null} hoveredNodeId - 鼠标悬停的节点 ID\r\n * @param {string} filePath - 自动保存的 JSON 文件路径\r\n */\nconst handleContextMenu = (params, hoveredNodeId, filePath) => {\n  params.event.preventDefault();\n  const menu = document.getElementById('nodeContextMenu');\n  menu.style.display = 'none';\n  if (hoveredNodeId !== null) {\n    const node = _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.nodes.get(hoveredNodeId);\n    menu.style.display = 'block';\n    menu.style.left = `${params.event.pageX}px`;\n    menu.style.top = `${params.event.pageY}px`;\n\n    /**\r\n     * 处理查看节点详情菜单项点击事件\r\n     */\n    const handleViewDetails = () => {\n      const detailContent = `\n                <h4>节点详情</h4>\n                <p>IP地址: ${node.label}</p>\n                <p>状态: ${node.state === 'up' ? '✅ 在线' : '❌ 离线'}</p>\n                <p>操作系统: ${node.os || '未知'}</p>\n                <p>MAC地址: ${node.mac_address || '未获取'}</p>\n                <p>开放端口: ${Array.isArray(node.open_ports) ? node.open_ports.map(p => p.port).join(', ') : typeof node.open_ports === 'object' ? node.open_ports.port : node.open_ports}</p>\n            `;\n      Swal.fire({\n        title: '节点信息',\n        html: detailContent,\n        confirmButtonText: '关闭',\n        width: '600px'\n      });\n      menu.style.display = 'none';\n    };\n    document.getElementById('viewDetails').onclick = handleViewDetails;\n\n    /**\r\n     * 处理修改节点信息菜单项点击事件\r\n     */\n    const handleModifyNode = () => {\n      Swal.fire({\n        title: '修改节点信息',\n        html: `\n                    <input id=\"swal-ip\" class=\"swal2-input\" placeholder=\"IP地址\" value=\"${node.label}\">\n                    <select id=\"swal-status\" class=\"swal2-select\">\n                        <option value=\"up\" ${node.state === 'up' ? 'selected' : ''}>在线</option>\n                        <option value=\"down\" ${node.state === 'down' ? 'selected' : ''}>离线</option>\n                    </select>\n                    <input id=\"swal-os\" class=\"swal2-input\" placeholder=\"操作系统\" value=\"${node.os || ''}\">\n                    <input id=\"swal-ports\" class=\"swal2-input\" \n                           placeholder=\"开放端口 (格式: 端口/协议, 如 80/http)\" \n                           value=\"${Array.isArray(node.open_ports) ? node.open_ports.map(p => `${p.port}${p.protocol ? '/' + p.protocol : ''}`).join(', ') : ''}\">\n                `,\n        focusConfirm: false,\n        preConfirm: () => {\n          const originalPorts = node.open_ports || [];\n          const inputPorts = document.getElementById('swal-ports').value.split(',').map(entry => {\n            const trimmed = entry.trim();\n            if (!trimmed) return null;\n            const [portStr, protocol = \"tcp\"] = trimmed.split('/');\n            const port = parseInt(portStr, 10);\n            return isNaN(port) ? null : {\n              port,\n              protocol: protocol.trim()\n            };\n          }).filter(Boolean);\n          if (inputPorts.length === 0) {\n            Swal.showValidationMessage('端口不能为空');\n            return false;\n          }\n          return {\n            label: document.getElementById('swal-ip').value,\n            status: document.getElementById('swal-status').value,\n            os: document.getElementById('swal-os').value,\n            ports: inputPorts.map(({\n              port,\n              protocol\n            }) => {\n              const existingPort = originalPorts.find(p => p.port === port);\n              return existingPort ? {\n                ...existingPort,\n                protocol\n              } : {\n                port,\n                protocol,\n                service: \"unknown\",\n                version: \"\"\n              };\n            })\n          };\n        }\n      }).then(result => {\n        if (result.isConfirmed) {\n          const data = result.value;\n          _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.nodes.update({\n            id: hoveredNodeId,\n            label: data.label,\n            state: data.status,\n            os: data.os,\n            open_ports: data.ports,\n            color: data.status === 'up' ? {\n              background: \"#F0E68C\",\n              border: \"#B8860B\"\n            } : {\n              background: \"#D3D3D3\",\n              border: \"#808080\"\n            }\n          });\n          _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.redraw();\n          (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.autoSaveToJSON)(filePath);\n        }\n      });\n      menu.style.display = 'none';\n    };\n    document.getElementById('modifyNode').onclick = handleModifyNode;\n\n    /**\r\n     * 处理删除节点菜单项点击事件\r\n     */\n    const handleDeleteNode = () => {\n      Swal.fire({\n        title: '确认删除节点？',\n        text: \"该操作将同时删除所有关联的连接！\",\n        icon: 'warning',\n        showCancelButton: true,\n        confirmButtonColor: '#d33',\n        cancelButtonColor: '#3085d6',\n        confirmButtonText: '确认删除'\n      }).then(result => {\n        if (result.isConfirmed) {\n          const connectedEdges = _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.getConnectedEdges(hoveredNodeId);\n          _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.nodes.remove(hoveredNodeId);\n          _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.edges.remove(connectedEdges);\n          _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.redraw();\n          (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.autoSaveToJSON)(filePath);\n        }\n      });\n      menu.style.display = 'none';\n    };\n    document.getElementById('deleteNode').onclick = handleDeleteNode;\n  }\n};\n\n/**\r\n * 处理页面点击事件，隐藏右键上下文菜单\r\n */\nconst handlePageClick = () => {\n  document.addEventListener('click', e => {\n    if (!e.target.closest('.custom-context-menu')) {\n      document.getElementById('nodeContextMenu').style.display = 'none';\n    }\n  });\n};\n\n/**\r\n * 设置漏洞分析按钮点击事件监听器\r\n */\nconst setupVulnerabilityAnalysisClick = () => {\n  const vulnerabilityAnalysisElement = document.getElementById('vulnerabilityAnalysis');\n  if (vulnerabilityAnalysisElement) {\n    vulnerabilityAnalysisElement.addEventListener('click', _dataHandlers_js__WEBPACK_IMPORTED_MODULE_3__.calculateVulnerability);\n  } else {\n    console.warn('未找到 id 为 vulnerabilityAnalysis 的元素');\n  }\n};\n\n/**\r\n * 处理子网节点双击事件\r\n * @param {Object} params - 双击事件参数\r\n * @param {string} filePath - 自动保存的 JSON 文件路径\r\n */\nconst handleSubnetDoubleClick = (params, filePath) => {\n  if (params.nodes.length > 0) {\n    const clickedNodeId = params.nodes[0];\n    const clickedNode = _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.nodes.get(clickedNodeId);\n    if (clickedNode.node_type === 'subnet') {\n      console.log(\"双击了subnet节点:\", clickedNode.label);\n      // 获取子节点\n      const connectedEdges = _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.getConnectedEdges(clickedNodeId);\n      const childNodes = [];\n      const edgesToHide = []; // 改为存储需要隐藏的边\n      const newEdges = [];\n      const newEdgeIds = []; // 新增：用于存储新添加边的id\n      connectedEdges.forEach(edgeId => {\n        const edge = _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.edges.get(edgeId);\n        const targetNodeId = edge.from === clickedNodeId ? edge.to : edge.from;\n        const targetNode = _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.nodes.get(targetNodeId);\n        if (targetNode.parent === clickedNode.label) {\n          childNodes.push(targetNodeId);\n          edgesToHide.push(edgeId); // 记录需要隐藏的边\n\n          // 获取连接到子节点的边\n          const childConnectedEdges = _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.getConnectedEdges(targetNodeId);\n          childConnectedEdges.forEach(childEdgeId => {\n            const childEdge = _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.edges.get(childEdgeId);\n            const otherNodeId = childEdge.from === targetNodeId ? childEdge.to : childEdge.from;\n            if (otherNodeId !== clickedNodeId) {\n              // 记录需要隐藏的边\n              edgesToHide.push(childEdgeId);\n              // 记录新的连接到subnet节点的边\n              newEdges.push({\n                from: otherNodeId,\n                to: clickedNodeId,\n                // 可以根据需要复制其他边的属性\n                length: childEdge.length,\n                edge_type: childEdge.edge_type,\n                protocol: childEdge.protocol,\n                layer: childEdge.layer,\n                color: childEdge.color\n              });\n            }\n          });\n        }\n      });\n\n      // 收缩或展开子节点\n      const isChildNodesVisible = childNodes.some(nodeId => _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.nodes.get(nodeId).hidden !== true);\n      console.log(\"当前子节点可见状态:\", isChildNodesVisible);\n      childNodes.forEach(nodeId => {\n        _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.nodes.update({\n          id: nodeId,\n          hidden: isChildNodesVisible\n        });\n      });\n      // 隐藏相关边\n      edgesToHide.forEach(edgeId => {\n        _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.edges.update({\n          id: edgeId,\n          hidden: isChildNodesVisible\n        });\n      });\n      // 添加新边\n      if (isChildNodesVisible) {\n        const addedEdges = _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.edges.add(newEdges);\n        newEdgeIds.push(...addedEdges); // 记录新添加边的id\n      } else {\n        const edgesToRemove = [];\n        newEdges.forEach(newEdge => {\n          const existingEdges = _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.edges.get({\n            filter: edge => edge.from === newEdge.from && edge.to === newEdge.to\n          });\n          existingEdges.forEach(edge => {\n            edgesToRemove.push(edge.id);\n          });\n        });\n        _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.edges.remove(edgesToRemove);\n      }\n\n      // 刷新网络以应用更改\n      _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.redraw();\n      (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.autoSaveToJSON)(filePath);\n    }\n  }\n};\n\n/**\r\n * 设置网络图事件监听\r\n * @param {string} filePath - 自动保存的 JSON 文件路径\r\n */\nconst setupNetworkEvents = filePath => {\n  let stabilizedTimer;\n  let hoveredNodeId = null;\n  // 网络稳定事件处理\n  _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.on(\"stabilized\", () => {\n    stabilizedTimer = handleStabilized(stabilizedTimer);\n  });\n\n  // 右键上下文菜单处理\n  _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.on(\"oncontext\", params => {\n    handleContextMenu(params, hoveredNodeId, filePath);\n  });\n\n  // 页面点击事件处理\n  handlePageClick();\n\n  // 双击事件处理\n  _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.on(\"doubleClick\", params => {\n    handleSubnetDoubleClick(params, filePath);\n  });\n  _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.on(\"hoverNode\", params => {\n    hoveredNodeId = params.node;\n  });\n  _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.on(\"blurNode\", () => {\n    hoveredNodeId = null;\n  });\n  _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.on(\"selectNode\", function (params) {});\n  _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.on(\"click\", function (params) {});\n  _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.on(\"dragging\", function (params) {});\n  _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.on(\"dragEnd\", function (params) {});\n  _utils_state_js__WEBPACK_IMPORTED_MODULE_2__.appState.network.on(\"zoom\", function (params) {});\n  setupVulnerabilityAnalysisClick();\n};\n\n//# sourceURL=webpack://network-topology/./src/js/renderer/handlers/eventHandlers.js?");

/***/ }),

/***/ "./src/js/renderer/mainControl.js":
/*!****************************************!*\
  !*** ./src/js/renderer/mainControl.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _handlers_dataHandlers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./handlers/dataHandlers.js */ \"./src/js/renderer/handlers/dataHandlers.js\");\n/* harmony import */ var _config_networkConfig_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config/networkConfig.js */ \"./src/js/renderer/config/networkConfig.js\");\n/* harmony import */ var _handlers_eventHandlers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./handlers/eventHandlers.js */ \"./src/js/renderer/handlers/eventHandlers.js\");\n/* harmony import */ var _utils_state_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/state.js */ \"./src/js/renderer/utils/state.js\");\n/**\n * 主入口模块 - 文件处理与网络初始化\n * 功能：处理Electron文件打开事件，构建网络拓扑结构\n */\n\n// 导入核心模块\n\n\n\n\n\n/* ====================== Electron文件事件处理 ====================== */\n// 监听文件打开事件（由Electron主进程触发）\nwindow.api.onFilePath(async filePath => {\n  try {\n    /* ---------------------- 文件读取与解析 ---------------------- */\n    // 异步读取文件内容\n    const content = await window.api.readFile(filePath);\n    console.log(\"文件路径:\", filePath);\n    // 解析JSON数据结构\n    const data = JSON.parse(content);\n    /* ---------------------- 销毁旧的网络实例 ---------------------- */\n    // 销毁旧网络实例（如果存在）\n    if (_utils_state_js__WEBPACK_IMPORTED_MODULE_3__.appState.network) {\n      _utils_state_js__WEBPACK_IMPORTED_MODULE_3__.appState.network.destroy(); // 释放资源\n      _utils_state_js__WEBPACK_IMPORTED_MODULE_3__.appState.network.off();\n      _utils_state_js__WEBPACK_IMPORTED_MODULE_3__.appState.network = null;\n    }\n    /* ---------------------- 数据初始化 ---------------------- */\n    // 清空现有数据\n    _utils_state_js__WEBPACK_IMPORTED_MODULE_3__.appState.nodes.clear();\n    _utils_state_js__WEBPACK_IMPORTED_MODULE_3__.appState.edges.clear();\n    _utils_state_js__WEBPACK_IMPORTED_MODULE_3__.appState.ipToId.clear();\n    console.log(\"iptoid:\" + _utils_state_js__WEBPACK_IMPORTED_MODULE_3__.appState.ipToId);\n    // 重置ID计数器\n    _utils_state_js__WEBPACK_IMPORTED_MODULE_3__.appState.idCounter = 1; // TODO: 需要与appState中的ID生成机制保持一致\n    // // 调试点1：验证原始数据\n    // console.log('原始节点数:', data.nodes.length);\n    // console.log('原始边数:', data.edges.length);\n    /* ---------------------- 节点处理 ---------------------- */\n    // 递归创建所有节点及子节点\n    data.nodes.forEach(node => (0,_handlers_dataHandlers_js__WEBPACK_IMPORTED_MODULE_0__.addNodeWithChildren)(node, data, null));\n\n    /* ---------------------- 边处理 ---------------------- */\n    // 添加及处理所有边\n    data.edges.forEach(edge => (0,_handlers_dataHandlers_js__WEBPACK_IMPORTED_MODULE_0__.addEdge)(edge, data));\n    // // 调试点2：验证处理后数据\n    // console.log('处理后节点数:', appState.nodes.length);\n    // console.log('处理后边数:', appState.edges.length);\n    // console.log('IP映射表大小:', appState.ipToId.size);\n    /* ---------------------- 网络可视化初始化 ---------------------- */\n    // DOM 容器重置\n    const container = document.getElementById('mynetwork');\n    // 创建vis.js网络实例\n    _utils_state_js__WEBPACK_IMPORTED_MODULE_3__.appState.network = new vis.Network(container, {\n      nodes: _utils_state_js__WEBPACK_IMPORTED_MODULE_3__.appState.nodes,\n      edges: _utils_state_js__WEBPACK_IMPORTED_MODULE_3__.appState.edges\n    }, (0,_config_networkConfig_js__WEBPACK_IMPORTED_MODULE_1__.getNetworkOptions)() // 获取预定义的网络配置\n    );\n    /* ---------------------- 事件监听设置 ---------------------- */\n    // 初始化网络交互事件\n    (0,_handlers_eventHandlers_js__WEBPACK_IMPORTED_MODULE_2__.setupNetworkEvents)(filePath);\n\n    // 执行脆弱性分析\n    // calculateVulnerability();\n  } catch (error) {\n    console.error('文件处理流程失败:', error);\n    // TODO: 添加用户可见的错误提示（如弹窗通知）\n  }\n});\n\n//# sourceURL=webpack://network-topology/./src/js/renderer/mainControl.js?");

/***/ }),

/***/ "./src/js/renderer/utils/state.js":
/*!****************************************!*\
  !*** ./src/js/renderer/utils/state.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   appState: () => (/* binding */ appState)\n/* harmony export */ });\nconst appState = {\n  idCounter: 1,\n  nodes: new vis.DataSet(),\n  edges: new vis.DataSet(),\n  ipToId: new Map(),\n  network: null,\n  // 提供自增方法\n  incrementId() {\n    return this.idCounter++;\n  }\n};\n\n//# sourceURL=webpack://network-topology/./src/js/renderer/utils/state.js?");

/***/ }),

/***/ "./src/js/renderer/utils/utils.js":
/*!****************************************!*\
  !*** ./src/js/renderer/utils/utils.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoSaveToJSON: () => (/* binding */ autoSaveToJSON),\n/* harmony export */   generateNodeTile: () => (/* binding */ generateNodeTile),\n/* harmony export */   parsePorts: () => (/* binding */ parsePorts)\n/* harmony export */ });\n/* harmony import */ var _state_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./state.js */ \"./src/js/renderer/utils/state.js\");\n\n// 处理端口信息格式化\nconst parsePorts = ports => {\n  if (!ports) return '无'; // 字段不存在\n  if (typeof ports === 'number') return ports; // 单个端口号（数字）\n  if (typeof ports === 'string') return ports; // 字符串格式的端口（如 \"80,443\"）\n\n  // 如果是数组\n  if (Array.isArray(ports)) {\n    // 提取对象中的 port 字段（如果元素是对象）\n    const portList = ports.map(item => {\n      if (typeof item === 'object' && item.port !== undefined) {\n        return item.port; // 从对象中提取端口号\n      }\n      return item; // 直接是数字或字符串\n    });\n    return portList.join(', ') || '无';\n  }\n  return '无'; // 其他未知类型\n};\n\n// 生成节点信息卡片\nconst generateNodeTile = node => {\n  // 深度处理 open_ports 字段\n  return `\n\t  <div style=\"padding:15px;\">\n\t\t<h5 style=\"margin-bottom:10px;\">IP(${node.node_id || '未知'})</h5>\n\t\t<h5 style=\"margin-bottom:10px;\">\n\t\t  状态：<span title=\"${node.state || '未知'}\">\n\t\t\t${node.state === 'up' ? '✅ 在线' : '❌ 离线'}\n\t\t  </span>\n\t\t</h5>\n\t\t<h5 style=\"margin-bottom:10px;\">操作系统：${node.os || '未知'}</h5>\n\t\t<h5 style=\"margin-bottom:10px;\">\n\t\t  开放端口：${parsePorts(node.open_ports)}\n\t\t</h5>\n\t\t<h5>MAC：${node.mac_address || '未知'}</h5>\n\t  </div>\n\t`;\n};\n\n// 自动保存功能\nconst autoSaveToJSON = filePath => {\n  const updatedData = {\n    nodes: _state_js__WEBPACK_IMPORTED_MODULE_0__.appState.nodes.get().map(node => ({\n      node_id: node.label,\n      node_type: node.node_type,\n      state: node.state,\n      fqdn: node.fqdn,\n      reverse_dns: node.reverse_dns,\n      mac_address: node.mac_address,\n      vendor: node.vendor,\n      open_ports: node.open_ports,\n      os: node.os,\n      children: node.children,\n      parent: node.parent\n    })),\n    edges: _state_js__WEBPACK_IMPORTED_MODULE_0__.appState.edges.get().map(edge => ({\n      from_node: _state_js__WEBPACK_IMPORTED_MODULE_0__.appState.nodes.get(edge.from).label,\n      to_node: _state_js__WEBPACK_IMPORTED_MODULE_0__.appState.nodes.get(edge.to).label,\n      edge_type: edge.edge_type,\n      protocol: edge.protocol,\n      layer: edge.layer\n    }))\n  };\n  window.api.writeFile(filePath, JSON.stringify(updatedData, null, 2));\n};\n\n//# sourceURL=webpack://network-topology/./src/js/renderer/utils/utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/renderer/mainControl.js");
/******/ 	
/******/ })()
;